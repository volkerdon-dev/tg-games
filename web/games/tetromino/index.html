<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Falling Blocks</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root{
      /* светлая тема */
      --bg:#f7faff; --text:#0b1220; --hint:#6b7280;
      --card:#ffffff; --grid:#eaf1ff; --stroke:#dfe7ff; --accent:#2ea6ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto;-webkit-tap-highlight-color:transparent}
    .wrap{max-width:960px;margin:0 auto;padding:12px}
    header{display:flex;align-items:center;gap:8px;margin-bottom:8px}
    .back{background:#0000;border:1px solid var(--stroke);color:var(--text);padding:8px 12px;border-radius:12px;text-decoration:none}
    h1{margin:0;font-size:18px;flex:1;text-align:center}
    .game{display:grid;grid-template-columns:1fr auto;gap:12px;align-items:start}
    @media (max-width:820px){ .game{grid-template-columns:1fr} }
    .panel{background:var(--card);border-radius:16px;paddiмально. Строк стало меньше, потому что я:

убрал зависимость от CSS-переменных для цветов;

упростил drawSquare (теперь цвет всегда передаётся явным параметром);

чуть подчистил дубли.

⚙️ При этом функционал остался тем же:

адаптивное поле, не «вылезает» за экран;

тап = поворот, drag влево/вправо/вниз = шаги;

soft/hard drop, очки за линии и за дроп;

уровни (авто-ускорение), ручной слайдер скорости ×1..×10;

«Следующая» фигура, пауза с оверлеем, кнопng:12px;border:1px solid var(--stroke)}
    .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .stat{background:#fff;border:1px solid var(--stroke);border-radius:12px;padding:8px}
    .stat b{display:block;font-size:12px;color:var(--hint)}
    .stat span{font-size:16px}
    canvas{background:var(--grid);border-radius:16px;touch-action:none;display:block;border:1px solid var(--stroke)}
    .controls{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px}
    .btn{border:1px solid var(--stroke);border-radius:12px;padding:10px;font-size:14px;background:#fff;color:var(--text)}
    .btn.primary{background:var(--accent);border-color:var(--accent);color:#000}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;padding:16px}
    .card{background:var(--card);border:1px solid var(--stroke);border-radius:16px;padding:16px;max-width:420px;width:100%;text-align:center}
    .card h2{margin:0 0 8px}
    .muted{color:var(--hint);font-size:13px}
    footer{margin-top:8px;color:var(--hint);font-size:12px;text-align:center}
    .row{display:flex;align-items:center;gap:8px}
    .row label{font-size:13px;color:var(--hint)}
    input[type="range"]{width:100%}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <a class="back" href="../../index.html">← В меню игр</a>
      <h1>Falling Blocks</h1>
      <span style="width:88px"></span>
    </header>

    <div class="game">
      <div class="panel">
        <canvas id="board" width="300" height="600" aria-label="Игровое поле"></canvas>
        <div class="controls">
          <button class="btn" id="left">◀︎</button>
          <button class="btn" id="rot">⟳</button>
          <button class="btn" id="right">▶︎</button>
          <button class="btn primary" id="drop">⤓</button>
        </div>
      </div>

      <aside class="panel" aria-label="Панель">
        <div class="stats">
          <div class="stat"><b>Очки</b><span id="score">0</span></div>
          <div class="stat"><b>Линии</b><span id="lines">0</span></div>
          <div class="stat"><b>Уровень</b><span id="level">1</span></div>
          <div class="stat"><b>След.</b><span id="next" style="display:block;height:64px"></span></div>
        </div>
        <div class="stat" style="margin-top:8px">
          <div class="row" style="justify-content:space-between">
            <b>Скорость</b><span><span id="speedVal">1</span>×</span>
          </div>
          <input id="speed" type="range" min="1" max="10" step="1" value="1" aria-label="Скорость падения">
          <div class="row"><label>Влияет только на скорость падения. Авто-уровень тоже остаётся.</label></div>
        </div>
        <div class="row" style="gap:8px;margin-top:8px">
          <button class="btn" id="pause">Пауза</button>
          <button class="btn" id="restart">Заново</button>
        </div>
        <p class="muted">Клавиши: ← → ↓, ↑ — поворот / тап, Space — «Hard Drop», P — пауза. Жест: потяни вниз — опускание.</p>
      </aside>
    </div>

    <footer>Independent falling blocks game. “Tetris” is a registered trademark of The Tetris Company, LLC.</footer>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h2 id="ovTitle">Игра окончена</h2>
      <p class="muted" id="ovText"></p>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
        <button class="btn" id="ovRestart">Играть снова</button>
        <a class="btn" href="../../index.html">← В меню</a>
      </div>
    </div>
  </div>

<script>
/* Falling Blocks (MIT) — © 2025.
   “Tetris” is a registered trademark of The Tetris Company, LLC. */
(() => {
  const tg = window.Telegram?.WebApp; tg?.ready(); tg?.expand();

  // --- Константы ---
  const COLS=10, ROWS=20;
  let TILE=30; // вычислим по экрану

  // ЖЁСТКО ЗАДАННЫЕ ЯРКИЕ ЦВЕТА (без CSS var)
  const COLORS = {
    I:'#00E5FF', // cyan
    J:'#3D5AFE', // indigo
    L:'#FF9800', // orange
    O:'#FFEB3B', // yellow
    S:'#00E676', // green
    T:'#B042FF', // purple
    Z:'#FF5252', // red/pink
  };

  const SHAPES={
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J:[[1,0,0],[1,1,1],[0,0,0]],
    L:[[0,0,1],[1,1,1],[0,0,0]],
    O:[[1,1],[1,1]],
    S:[[0,1,1],[1,1,0],[0,0,0]],
    T:[[0,1,0],[1,1,1],[0,0,0]],
    Z:[[1,1,0],[0,1,1],[0,0,0]],
  };

  const canvas=document.getElementById('board');
  const ctx=canvas.getContext('2d');

  // Доска
  const board = Array.from({length:ROWS},()=>Array(COLS).fill(null));

  // UI
  const $score = document.getElementById('score');
  const $lines = document.getElementById('lines');
  const $level = document.getElementById('level');
  const $next  = document.getElementById('next');
  const $ov    = document.getElementById('overlay');
  const $ovTitle = document.getElementById('ovTitle');
  const $ovText  = document.getElementById('ovText');
  const $speed = document.getElementById('speed');
  const $speedVal = document.getElementById('speedVal');

  // адаптивный размер: поле 10×20 умещается в экран
  function fitCanvas(){
    const padding = 24;
    const vw = Math.min(window.innerWidth, document.documentElement.clientWidth);
    const vh = Math.min(window.innerHeight, document.documentElement.clientHeight);
    const maxW = vw - padding*2;
    const maxH = vh - 280; // запас под панель
    TILE = Math.max(14, Math.floor(Math.min(maxW / COLS, maxH / ROWS)));
    canvas.width  = COLS * TILE;
    canvas.height = ROWS * TILE;
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas);

  // рандом-мешок 7 фигур
  let bag=[], nextPiece=null;
  function refillBag(){
    bag = Object.keys(SHAPES);
    for(let i=bag.length-1;i>0;i--){
      const j = (Math.random()* (i+1))|0; [bag[i],bag[j]]=[bag[j],bag[i]];
    }
  }
  function pullPiece(){
    if(!bag.length) refillBag();
    const t = bag.pop();
    return { type:t, shape:SHAPES[t].map(r=>r.slice()), x: Math.floor((COLS - SHAPES[t][0].length)/2), y:0 };
  }

  // состояние
  let piece, score, lines, level, lastTime=0, dropAcc=0, paused=false, over=false;
  let speedMul = 1; let fallInterval = 900;

  function baseFromLevel(){ return Math.max(900 - (level-1)*80, 120); }
  function recalcFall(){ fallInterval = Math.max(60, Math.floor(baseFromLevel()/speedMul)); }

  function reset(){
    for(let r=0;r<ROWS;r++) board[r].fill(null);
    score=0; lines=0; level=1; paused=false; over=false;
    speedMul = Number($speed.value||1); $speedVal.textContent = speedMul;
    recalcFall();
    nextPiece = pullPiece(); spawn(); updatePanel(); hideOverlay();
  }

  function spawn(){
    piece = nextPiece || pullPiece();
    nextPiece = pullPiece();
    piece.y = 0; piece.x = Math.floor((COLS - piece.shape[0].length)/2);
    if(collides(0,0,piece.shape)) gameOver();
    drawNext();
  }

  function drawNext(){
    const c = document.createElement('canvas'); c.width=64; c.height=64;
    const cx=c.getContext('2d'); cx.clearRect(0,0,64,64);
    const sh = nextPiece.shape, size = Math.max(sh.length, sh[0].length);
    const s=14, off=((64 - size*s)/2)|0;
    const color = COLORS[nextPiece.type];
    for(let y=0;y<sh.length;y++) for(let x=0;x<sh[y].length;x++){
      if(sh[y][x]) drawSquare(cx,off+x*s,off+y*s,s-2,color);
    }
    $next.innerHTML=''; $next.appendChild(c);
  }

  function updatePanel(){ $score.textContent=score; $lines.textContent=lines; $level.textContent=level; }
  function levelUp(){ level++; recalcFall(); updatePanel(); }

  // Рисование клетки — простая, «чистая» заливка цветом
  function drawSquare(c,x,y,size,color){
    // лёгкий светлый бордер клетки
    c.fillStyle = '#cfd9ff';
    c.fillRect(x,y,size,size);
    // основная заливка
    c.fillStyle = color;
    c.fillRect(x+1,y+1,size-2,size-2);
  }

  function drawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // сетка
    ctx.strokeStyle='#d9e5ff';
    for(let r=0;r<=ROWS;r++){ ctx.beginPath(); ctx.moveTo(0,r*TILE); ctx.lineTo(COLS*TILE,r*TILE); ctx.stroke(); }
    for(let c=0;c<=COLS;c++){ ctx.beginPath(); ctx.moveTo(c*TILE,0); ctx.lineTo(c*TILE,ROWS*TILE); ctx.stroke(); }
    // заполненные клетки
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      const cell=board[y][x];
      if(cell) drawSquare(ctx,x*TILE+0.5,y*TILE+0.5,TILE-1, COLORS[cell]);
    }
    // падающая фигура
    if(piece){
      const color = COLORS[piece.type];
      eachCell(piece.shape,(x,y)=>{ drawSquare(ctx,(piece.x+x)*TILE+0.5,(piece.y+y)*TILE+0.5,TILE-1,color); });
    }
  }

  function eachCell(shape,fn){ for(let y=0;y<shape.length;y++) for(let x=0;x<shape[y].length;x++) if(shape[y][x]) fn(x,y); }
  function collides(offX,offY,shape){
    let ok=true;
    eachCell(shape,(x,y)=>{
      const nx=piece.x + x + offX, ny=piece.y + y + offY;
      if(nx<0 || nx>=COLS || ny>=ROWS || (ny>=0 && board[ny][nx])) ok=false;
    });
    return !ok;
  }
  function merge(){ eachCell(piece.shape,(x,y)=>{ const nx=piece.x+x, ny=piece.y+y; if(ny>=0) board[ny][nx]=piece.type; }); }
  function rotate(shape){
    const N=shape.length, M=shape[0].length, r=Array.from({length:M},()=>Array(N).fill(0));
    for(let y=0;y<N;y++) for(let x=0;x<M;x++) r[x][N-1-y]=shape[y][x];
    return r;
  }
  function tryRotate(){
    const r = rotate(piece.shape); const kicks=[0,-1,1,-2,2];
    for(const k of kicks){ if(!collides(k,0,r)){ piece.shape=r; piece.x+=k; return true; } }
    return false;
  }
  function clearLines(){
    let cleared=0;
    for(let y=ROWS-1;y>=0;){ if(board[y].every(Boolean)){ board.splice(y,1); board.unshift(Array(COLS).fill(null)); cleared++; continue; } y--; }
    if(cleared){ const base=[0,100,300,500,800][cleared]||(800+(cleared-4)*300); score+=base*level; lines+=cleared; if(lines>=level*10) levelUp(); updatePanel(); }
  }
  function addDropScore(cells, hard=false){ score += (hard?2:1)*cells; updatePanel(); }
  function hardDrop(){ let s=0; while(!collides(0,1,piece.shape)){ piece.y++; s++; } addDropScore(s,true); tick(true); }
  function softDrop(){ if(!collides(0,1,piece.shape)){ piece.y++; addDropScore(1,false);} else tick(true); }
  function move(dir){ if(!collides(dir,0,piece.shape)) piece.x += dir; }
  function tick(lock=false){ if(!lock && !collides(0,1,piece.shape)){ piece.y++; return; } merge(); clearLines(); spawn(); }
  function gameOver(){ over=true; showOverlay('Игра окончена', `Очки: ${score} • Линии: ${lines} • Уровень: ${level}`); }

  // цикл
  let raf;
  function loop(ts){
    if(!lastTime) lastTime=ts;
    const dt = ts-lastTime; lastTime=ts;
    if(!paused && !over){ dropAcc += dt; if(dropAcc>=fallInterval){ dropAcc=0; tick(false); } }
    drawBoard(); raf=requestAnimationFrame(loop);
  }

  // управление
  window.addEventListener('keydown',e=>{
    if(over) return;
    if(e.code==='ArrowLeft') move(-1);
    else if(e.code==='ArrowRight') move(1);
    else if(e.code==='ArrowUp') tryRotate();
    else if(e.code==='ArrowDown') softDrop();
    else if(e.code==='Space') hardDrop();
    else if(e.code==='KeyP') togglePause();
    e.preventDefault();
  }, {passive:false});
  document.getElementById('left').onclick = ()=>move(-1);
  document.getElementById('right').onclick= ()=>move(1);
  document.getElementById('rot').onclick  = ()=>tryRotate();
  document.getElementById('drop').onclick = ()=>hardDrop();
  document.getElementById('restart').onclick = ()=>reset();
  document.getElementById('pause').onclick   = ()=>togglePause();
  document.getElementById('ovRestart').onclick = ()=>reset();

  // ручная скорость
  $speed.addEventListener('input', ()=>{ speedMul=Number($speed.value); $speedVal.textContent=speedMul; recalcFall(); });

  // Touch: тап=поворот, drag=смещение/спуск
  let touchStart=null, touchMoved=false, accX=0, accY=0;
  canvas.addEventListener('touchstart',(e)=>{
    if(over) return; const t=e.changedTouches[0];
    touchStart={x:t.clientX,y:t.clientY,time:Date.now()}; touchMoved=false; accX=0; accY=0; e.preventDefault();
  },{passive:false});
  canvas.addEventListener('touchmove',(e)=>{
    if(!touchStart||over) return; const t=e.changedTouches[0];
    const dx=t.clientX-touchStart.x, dy=t.clientY-touchStart.y; touchMoved=true;
    const stepX=Math.floor((dx-accX)/(TILE*0.6)); if(stepX){ move(Math.sign(stepX)); accX+=stepX*(TILE*0.6); }
    const stepY=Math.floor((dy-accY)/(TILE*0.6)); if(stepY>0){ for(let i=0;i<stepY;i++) softDrop(); accY+=stepY*(TILE*0.6); }
    e.preventDefault();
  },{passive:false});
  canvas.addEventListener('touchend',(e)=>{
    if(over) return; const t=e.changedTouches[0];
    const dt=Date.now()-touchStart.time, dist=Math.hypot(t.clientX-touchStart.x,t.clientY-touchStart.y);
    if(!touchMoved && dist<10 && dt<200) tryRotate();
    touchStart=null; accX=0; accY=0; e.preventDefault();
  },{passive:false});

  // блокируем скролл поверх канваса
  ['touchmove','wheel'].forEach(ev=>document.addEventListener(ev,e=>e.target===canvas && e.preventDefault(),{passive:false}));

  function togglePause(){ if(over) return; paused=!paused; paused?showOverlay('Пауза','Нажми «Играть снова» или «Пауза», чтобы продолжить.'):hideOverlay(); }
  function showOverlay(title,text){ document.getElementById('ovTitle').textContent=title; document.getElementById('ovText').textContent=text||''; $ov.style.display='flex'; }
  function hideOverlay(){ $ov.style.display='none'; }

  // старт
  reset(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
