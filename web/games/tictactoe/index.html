<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tic-Tac-Toe</title>
  <style>
    :root{
      --tile:#0f1115; --tile-border:#1c1f26;
      --x:#10b981;    /* X = зелёный */
      --o:#facc15;    /* O = жёлтый */
      --accent:#ef4444; --text:#111827; --muted:#6b7280;
    }
    html,body{margin:0;padding:0;background:#fff;color:var(--text);
      font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    .wrap{max-width:760px;margin:0 auto;padding:16px;position:relative;}
    h1{font-size:28px;font-weight:800;display:flex;gap:8px;align-items:center;margin:0 0 8px;}
    h1 .x{color:var(--accent);}
    .topbar{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap}
    .status-top{min-height:28px;margin:4px 0 8px;font-size:18px;font-weight:700}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0 12px;}
    .muted{color:var(--muted)}
    .btn{padding:8px 14px;border-radius:14px;border:1px solid #e5e7eb;background:#f3f4f6;cursor:pointer}
    .btn:active{transform:scale(.98)}
    .btn.dark,.btn.primary{background:#111827;color:#f9fafb;border-color:#111827}
    .btn.ghost{background:transparent;border-color:#e5e7eb}
    .seg{display:inline-flex;background:#111827;border-radius:12px;overflow:hidden}
    .seg button{background:transparent;border:none;color:#f9fafb;padding:8px 12px;cursor:pointer}
    .seg button.active{background:#374151}
    .grid-wrap{position:relative;margin-top:12px}
    .grid{display:grid;gap:12px}
    .cell{
      aspect-ratio:1/1;border-radius:18px;background:var(--tile);
      border:1px solid var(--tile-border);
      box-shadow:0 1px 3px rgba(0,0,0,.2);
      display:flex;align-items:center;justify-content:center;
      touch-action:manipulation;user-select:none;-webkit-user-select:none;
      min-height:84px;
    }
    .cell:active{transform:scale(.99)}
    .mark{font-size:56px;line-height:1;font-weight:900;letter-spacing:-.02em;text-shadow:0 0 1px rgba(0,0,0,.25)}
    .mark.x{color:var(--x)} .mark.o{color:var(--o)}
    .info-row{display:none;gap:10px;align-items:center;margin:8px 0 4px}
    /* линия победы */
    .overlay{position:absolute;inset:0;pointer-events:none}
    .overlay line{
      stroke-width:10px;stroke-linecap:round;
      filter:drop-shadow(0 1px 2px rgba(0,0,0,.35));
      stroke-dasharray:600; stroke-dashoffset:600; animation: draw 350ms ease-out forwards;
    }
    @keyframes draw { to { stroke-dashoffset:0; } }
    /* счёт */
    .score{display:flex;gap:10px;align-items:center}
    .badge{border:1px solid #e5e7eb;border-radius:12px;padding:6px 10px;background:#fff}
    /* GAME OVER overlay */
    .gameover{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(17,24,39,.55); backdrop-filter: blur(2px); z-index:5;
    }
    .toast{
      background:#fff; color:#111827; border-radius:16px; padding:18px 18px 14px;
      box-shadow:0 10px 30px rgba(0,0,0,.35); text-align:center; min-width:260px;
      animation: pop .18s ease-out;
    }
    .toast h3{margin:0 0 8px; font-size:20px}
    .toast p{margin:0 0 12px}
    @keyframes pop{ from{ transform:scale(.96); opacity:.6 } to{ transform:scale(1); opacity:1 } }
    @media (max-width:420px){ .mark{font-size:48px} }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <h1><span class="x">✖</span> Tic-Tac-Toe</h1>
    <div class="score">
      <span class="badge">X побед: <b id="scoreX">0</b></span>
      <span class="badge">O побед: <b id="scoreO">0</b></span>
      <span class="badge">Ничьи: <b id="scoreD">0</b></span>
    </div>
  </div>

  <div id="statusTop" class="status-top"></div>

  <div class="row">
    <span class="muted">Режим:</span>
    <div class="seg" id="modeSeg">
      <button data-size="3" data-win="3" class="active">Классика 3×3</button>
      <button data-size="4" data-win="4">Средняя 4×4</button>
      <button data-size="5" data-win="5">Усложнённая 5×5</button>
    </div>

    <span class="muted">Сложность:</span>
    <div class="seg" id="diffSeg">
      <button data-diff="easy">Лёгкая</button>
      <button data-diff="medium" class="active">Средняя</button>
      <button data-diff="hard">Сложная</button>
    </div>
  </div>

  <!-- выбор стороны (теперь прячем по умолчанию, т.к. X выбран автоматически) -->
  <div class="row" id="chooseRow" style="display:none">
    <span class="muted">Выбери, кем играть:</span>
    <button class="btn dark" id="playX">Play as X</button>
    <button class="btn dark" id="playO">Play as O</button>
  </div>

  <div class="info-row" id="infoRow">
    <span>Ход: <b id="turnLabel">X</b></span>
    <button class="btn" id="resetBtn">Сброс</button>
    <button class="btn primary" id="againBtn" style="display:none">Сыграть ещё</button>
    <button class="btn ghost" id="changeSideBtn">Сменить сторону</button>
  </div>

  <div class="grid-wrap">
    <div class="grid" id="board"></div>
    <svg class="overlay" id="winSvg"></svg>
    <!-- Оверлей «Игра окончена» -->
    <div class="gameover" id="gameover">
      <div class="toast">
        <h3 id="goTitle">Игра окончена</h3>
        <p id="goText">Победитель: —</p>
        <div style="display:flex;gap:8px;justify-content:center">
          <button class="btn primary" id="goAgain">Сыграть ещё</button>
          <button class="btn" id="goClose">Закрыть</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  const boardEl   = document.getElementById('board');
  const statusTop = document.getElementById('statusTop');
  const turnLabel = document.getElementById('turnLabel');
  const chooseRow = document.getElementById('chooseRow');
  const infoRow   = document.getElementById('infoRow');
  const btnX      = document.getElementById('playX');
  const btnO      = document.getElementById('playO');
  const resetBtn  = document.getElementById('resetBtn');
  const againBtn  = document.getElementById('againBtn');
  const changeSideBtn = document.getElementById('changeSideBtn');
  const winSvg    = document.getElementById('winSvg');
  const modeSeg   = document.getElementById('modeSeg');
  const diffSeg   = document.getElementById('diffSeg');

  const goLayer   = document.getElementById('gameover');
  const goTitle   = document.getElementById('goTitle');
  const goText    = document.getElementById('goText');
  const goAgain   = document.getElementById('goAgain');
  const goClose   = document.getElementById('goClose');

  const scoreXEl  = document.getElementById('scoreX');
  const scoreOEl  = document.getElementById('scoreO');
  const scoreDEl  = document.getElementById('scoreD');

  let size = 3, winLen = 3;
  let diff = 'medium'; // easy/medium/hard (для 4×4/5×5)
  let board, player, ai, turn, lines;
  let scoreX=0, scoreO=0, scoreD=0;

  function updateScoreUI(){ scoreXEl.textContent=scoreX; scoreOEl.textContent=scoreO; scoreDEl.textContent=scoreD; }

  function genLines(n,k){
    const L=[];
    for(let r=0;r<n;r++){ for(let c=0;c<=n-k;c++){ const a=[]; for(let t=0;t<k;t++) a.push(r*n+c+t); L.push(a); } }
    for(let c=0;c<n;c++){ for(let r=0;r<=n-k;r++){ const a=[]; for(let t=0;t<k;t++) a.push((r+t)*n+c); L.push(a); } }
    for(let r=0;r<=n-k;r++){ for(let c=0;c<=n-k;c++){ const a=[]; for(let t=0;t<k;t++) a.push((r+t)*n+(c+t)); L.push(a); } }
    for(let r=0;r<=n-k;r++){ for(let c=k-1;c<n;c++){ const a=[]; for(let t=0;t<k;t++) a.push((r+t)*n+(c-t)); L.push(a); } }
    return L;
  }
  function checkWinner(b){
    for(const ln of lines){
      const f=b[ln[0]]; if(!f) continue;
      let ok=true; for(let i=1;i<ln.length;i++) if(b[ln[i]]!==f){ ok=false; break; }
      if(ok) return {winner:f, line:ln};
    } return null;
  }
  const empties = (b)=> b.map((v,i)=>v?null:i).filter(v=>v!==null);
  const isDraw  = (b)=> !checkWinner(b) && empties(b).length===0;

  // minimax 3×3
  function minimax(b, pNow, aiM, huM, a, bt){
    const cw=checkWinner(b); if(cw) return {score:cw.winner===aiM?10:-10};
    if(isDraw(b)) return {score:0};
    const max=pNow===aiM; let best={score:max?-Infinity:Infinity, idx:-1};
    for(const i of empties(b)){
      const c=b.slice(); c[i]=pNow;
      const nx=minimax(c, pNow===aiM?huM:aiM, aiM, huM, a, bt);
      if(max){ if(nx.score>best.score) best={score:nx.score,idx:i}; a=Math.max(a,nx.score); }
      else{ if(nx.score<best.score) best={score:nx.score,idx:i}; bt=Math.min(bt,nx.score); }
      if(bt<=a) break;
    }
    return best;
  }
  function bestMove3(b, aiM, huM){
    let best={idx:empties(b)[0],score:-Infinity};
    for(const i of empties(b)){
      const c=b.slice(); c[i]=aiM;
      const r=minimax(c, huM, aiM, huM, -Infinity, Infinity);
      if(r.score>best.score) best={idx:i,score:r.score};
    }
    return best.idx;
  }

  // эвристики для 4×4/5×5
  function heuristic(b, aiM, huM){
    let s=0;
    for(const ln of lines){
      const vals=ln.map(i=>b[i]);
      const aiCnt=vals.filter(v=>v===aiM).length;
      const huCnt=vals.filter(v=>v===huM).length;
      if(aiCnt>0 && huCnt>0) continue;
      s += (aiCnt*aiCnt)*3 + (huCnt===0?1:0);
      if(huCnt>0 && aiCnt===0) s -= huCnt*2;
    }
    return s;
  }
  function bestMoveLarge(b, aiM, huM){
    const empty=empties(b); if(empty.length===0) return -1;
    if(diff==='easy') return empty[Math.floor(Math.random()*empty.length)];
    for(const i of empty){ const c=b.slice(); c[i]=aiM; if(checkWinner(c)) return i; }
    for(const i of empty){ const c=b.slice(); c[i]=huM; if(checkWinner(c)) return i; }
    if(diff==='medium'){
      let bestIdx=empty[0], bestScore=-1, center=Math.floor((size*size)/2);
      for(const i of empty){ const c=b.slice(); c[i]=aiM; let v=heuristic(c, aiM, huM); if(i===center) v+=4; if(v>bestScore){bestScore=v; bestIdx=i;} }
      return bestIdx;
    }
    // hard: lookahead 1-плай
    let bestIdx=empty[0], bestVal=-Infinity;
    for(const i of empty){
      const after=b.slice(); after[i]=aiM;
      let worst=Infinity; const rep=empties(after);
      if(rep.length===0){ const v=heuristic(after, aiM, huM); if(v>bestVal){bestVal=v; bestIdx=i;} continue; }
      for(const j of rep){ const h=after.slice(); h[j]=huM; const v=heuristic(h, aiM, huM); if(v<worst) worst=v; }
      if(worst>bestVal){ bestVal=worst; bestIdx=i; }
    }
    return bestIdx;
  }

  function aiMove(){
    const idx = (size===3) ? bestMove3(board, ai, player) : bestMoveLarge(board, ai, player);
    placeMark(idx, ai);
    if (endIfNeeded()) return;
    turn=player; turnLabel.textContent=turn;
  }

  // построение/инициализация
  function buildBoard(){
    boardEl.style.gridTemplateColumns=`repeat(${size},1fr)`;
    boardEl.innerHTML=''; winSvg.innerHTML='';
    board=Array(size*size).fill(null);
    for(let i=0;i<size*size;i++){
      const b=document.createElement('button');
      b.className='cell'; b.dataset.idx=i;
      b.addEventListener('click', onCellClick);
      const s=document.createElement('span');
      s.className='mark'; s.textContent='·'; s.style.opacity='0';
      b.appendChild(s);
      boardEl.appendChild(b);
    }
    againBtn.style.display='none';
    goLayer.style.display='none';
  }
  function init(){
    lines=genLines(size, winLen);
    buildBoard();
    statusTop.textContent='';
    turn='X'; turnLabel.textContent=turn;
    winSvg.innerHTML='';
  }

  function placeMark(i, mark){
    if(i<0) return;
    board[i]=mark;
    const cell=boardEl.querySelector(`.cell[data-idx="${i}"]`);
    const span=cell.querySelector('.mark');
    span.textContent=mark; span.style.opacity='1';
    span.classList.toggle('x', mark==='X');
    span.classList.toggle('o', mark==='O');
  }

  function drawWinLine(win){
    const line=win.line, aIdx=line[0], bIdx=line[line.length-1];
    const aEl=boardEl.querySelector(`.cell[data-idx="${aIdx}"]`);
    const bEl=boardEl.querySelector(`.cell[data-idx="${bIdx}"]`);
    const gridRect=boardEl.getBoundingClientRect();
    const ar=aEl.getBoundingClientRect(), br=bEl.getBoundingClientRect();
    const ax=ar.left-gridRect.left+ar.width/2, ay=ar.top-gridRect.top+ar.height/2;
    const bx=br.left-gridRect.left+br.width/2, by=br.top-gridRect.top+br.height/2;
    winSvg.innerHTML='';
    const l=document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1',ax); l.setAttribute('y1',ay);
    l.setAttribute('x2',bx); l.setAttribute('y2',by);
    l.setAttribute('stroke', win.winner==='X'
      ? getComputedStyle(document.documentElement).getPropertyValue('--x')
      : getComputedStyle(document.documentElement).getPropertyValue('--o'));
    winSvg.appendChild(l);
  }

  function showGameOver(text){
    goTitle.textContent = 'Игра окончена';
    goText.textContent  = text;
    goLayer.style.display='flex';
  }

  function endIfNeeded(){
    const res=checkWinner(board);
    if (res){
      statusTop.textContent=`Победитель: ${res.winner}`;
      drawWinLine(res);
      if (res.winner==='X') scoreX++; else scoreO++;
      updateScoreUI();
      againBtn.style.display='inline-block';
      showGameOver(`Победил ${res.winner}`);
      turn=null; return true;
    }
    if (isDraw(board)){
      statusTop.textContent='Ничья';
      scoreD++; updateScoreUI();
      againBtn.style.display='inline-block';
      showGameOver('Ничья');
      turn=null; return true;
    }
    return false;
  }

  function onCellClick(e){
    const idx=+e.currentTarget.dataset.idx;
    if (!player || turn!==player) return;
    if (board[idx]) return;
    placeMark(idx, player);
    if (endIfNeeded()) return;
    turn=ai; turnLabel.textContent=turn;
    setTimeout(aiMove, 120);
  }

  function maybeStartAIIfFirst(){
    if (player==='O' && ai==='X' && turn==='X') setTimeout(aiMove, 120);
  }

  // handlers
  // авто-выбор: по умолчанию играем за X
  function chooseXByDefault(){
    player='X'; ai='O';
    chooseRow.style.display='none';
    infoRow.style.display='flex';
    init(); // X ходит первым
  }

  btnX.onclick = ()=>{ player='X'; ai='O'; chooseRow.style.display='none'; infoRow.style.display='flex'; init(); };
  btnO.onclick = ()=>{ player='O'; ai='X'; chooseRow.style.display='none'; infoRow.style.display='flex'; init(); maybeStartAIIfFirst(); };

  resetBtn.onclick = ()=>{ init(); if (player && ai) maybeStartAIIfFirst(); };
  againBtn.onclick = ()=>{ init(); if (player && ai) maybeStartAIIfFirst(); };
  changeSideBtn.onclick = ()=>{
    // показать выбор стороны
    infoRow.style.display='none'; chooseRow.style.display='flex';
  };

  goAgain.onclick = ()=>{ goLayer.style.display='none'; againBtn.click(); };
  goClose.onclick = ()=>{ goLayer.style.display='none'; };

  modeSeg.addEventListener('click',(e)=>{
    const btn=e.target.closest('button'); if(!btn) return;
    [...modeSeg.querySelectorAll('button')].forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    size=+btn.dataset.size; winLen=+btn.dataset.win;
    // новый режим = новая партия; оставляем текущую сторону, если уже выбрана
    init(); if (player && ai) maybeStartAIIfFirst();
  });

  diffSeg.addEventListener('click',(e)=>{
    const btn=e.target.closest('button'); if(!btn) return;
    [...diffSeg.querySelectorAll('button')].forEach(b=>b.classList.remove('active'));
    btn.classList.add('active'); diff=btn.dataset.diff;
  });

  // старт: уже выбран X по умолчанию
  updateScoreUI();
  chooseXByDefault();
</script>
</body>
</html>
