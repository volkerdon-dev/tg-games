<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Rocky Ball</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  html,body{margin:0;height:100%;background:#2b2433;color:#fff;font-family:system-ui,Inter,Segoe UI}
  #hud{position:fixed;top:8px;left:8px;background:rgba(0,0,0,.35);padding:6px 10px;border-radius:10px;font-weight:700;z-index:10}
  #controls{position:fixed;bottom:12px;left:0;right:0;display:flex;justify-content:center;gap:10px;z-index:10}
  .btn{border:0;border-radius:14px;padding:12px 16px;background:#23283a;color:#fff;min-width:84px}
  .btn:active{transform:scale(.98)}
  canvas{display:block}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">❤️ <span id="hp">3</span> • <span id="rings">0</span>/<span id="total">0</span> • Level 1</div>
<div id="controls">
  <button class="btn" id="left">⟵</button>
  <button class="btn" id="jump">⤒</button>
  <button class="btn" id="right">⟶</button>
</div>

<script>
/* --- bootstrap --- */
const tg = window.Telegram?.WebApp; try{ tg?.ready(); tg?.expand(); }catch(e){}

/* --- canvas & resize (без зависимостей) --- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W=0,H=0,DPR=1;
function resize(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
  W = Math.floor(window.innerWidth);
  H = Math.floor(window.innerHeight);
  canvas.width = Math.floor(W*DPR);
  canvas.height = Math.floor(H*DPR);
  canvas.style.width = W+'px';
  canvas.style.height = H+'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = false;
}
window.addEventListener('resize', resize, {passive:true});
resize();

/* --- HUD refs --- */
const hpEl = document.getElementById('hp');
const rEl  = document.getElementById('rings');
const tEl  = document.getElementById('total');

/* --- уровень: . пусто | 1 блок | 2 шип | 3 кольцо | 4 портал | S старт --- */
const TILE = 32;
let level = [
  "11111111111111111111111111111111",
  "1..............................1",
  "1..........................3...1",
  "1..............11111111111.....1",
  "1..............................1",
  "1.S..............1..........4..1",
  "1111111111..2..11111111111111111"
];
// NB: массив строк — допустимо перезаписывать level[y] новым string

const H_TILES = level.length, W_TILES = level[0].length;
const MAP_W = W_TILES*TILE, MAP_H = H_TILES*TILE;
const solids = new Set(['1']);
const tileAt = (x,y)=> (x<0||y<0||x>=W_TILES||y>=H_TILES) ? '1' : level[y][x];
const isSolid = (c)=> solids.has(c);

/* --- player state --- */
const state = {
  lives:3, rings:0, total:(level.join('').match(/3/g) || []).length,
  px:0, py:0, vx:0, vy:0, onGround:false, spawn:{x:0,y:0}
};
tEl.textContent = state.total;

/* --- найти старт S --- */
(function findStart(){
  let found=false;
  for(let y=0;y<H_TILES;y++){
    for(let x=0;x<W_TILES;x++){
      if(level[y][x]==='S'){
        state.spawn = {x:x*TILE, y:(y-1)*TILE};
        found=true; break;
      }
    }
    if(found) break;
  }
  if(!found){ state.spawn={x:2*TILE,y:(H_TILES-3)*TILE}; }
  state.px=state.spawn.x; state.py=state.spawn.y;
})();

/* --- управление --- */
const keys = {left:false,right:false};
document.getElementById('left').onpointerdown = ()=> keys.left=true;
document.getElementById('right').onpointerdown= ()=> keys.right=true;
window.addEventListener('pointerup',()=>{ keys.left=false; keys.right=false; }, {passive:true});
document.getElementById('jump').onpointerdown = ()=>{ if(state.onGround){ state.vy=-680; state.onGround=false; } };

window.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft'||e.key==='a')  keys.left=true;
  if(e.key==='ArrowRight'||e.key==='d') keys.right=true;
  if(e.key===' '||e.key==='ArrowUp'||e.key==='w'){ if(state.onGround){ state.vy=-680; state.onGround=false; } }
});
window.addEventListener('keyup',e=>{
  if(e.key==='ArrowLeft'||e.key==='a')  keys.left=false;
  if(e.key==='ArrowRight'||e.key==='d') keys.right=false;
});

/* --- коллизии по тайлам (исправленная ось X/Y) --- */
function resolveAABB(px,py,w,h,vx,vy){
  // X
  let nx = px + vx, ny = py;
  let L = Math.floor(nx/TILE), R = Math.floor((nx+w-1)/TILE);
  let T = Math.floor(ny/TILE), B = Math.floor((ny+h-1)/TILE);
  if(vx>0 && (isSolid(tileAt(R,T)) || isSolid(tileAt(R,B)))){ nx = R*TILE - w; vx = 0; }
  if(vx<0 && (isSolid(tileAt(L,T)) || isSolid(tileAt(L,B)))){ nx = (L+1)*TILE; vx = 0; }
  nx = Math.max(0, Math.min(nx, MAP_W - w));

  // Y
  let ny2 = ny + vy;
  L = Math.floor(nx/TILE); R = Math.floor((nx+w-1)/TILE);
  T = Math.floor(ny2/TILE); B = Math.floor((ny2+h-1)/TILE);
  let onGround=false;
  if(vy>0 && (isSolid(tileAt(L,B)) || isSolid(tileAt(R,B)))){ ny2 = B*TILE - h; vy=0; onGround=true; }
  if(vy<0 && (isSolid(tileAt(L,T)) || isSolid(tileAt(R,T)))){ ny2 = (T+1)*TILE; vy=0; }
  ny2 = Math.max(0, Math.min(ny2, MAP_H - h));
  return {x:nx,y:ny2,vx,vy,onGround};
}

/* --- игровая логика --- */
function resetToCheckpoint(){ state.px=state.spawn.x; state.py=state.spawn.y; state.vx=0; state.vy=0; state.onGround=false; }
function hit(){ state.lives--; hpEl.textContent=state.lives; if(state.lives<=0){ gameOver(); } else { resetToCheckpoint(); } }
function gameOver(){ alert(`Game Over. Rings: ${state.rings}`); state.lives=3; hpEl.textContent=3; state.rings=0; rEl.textContent=0; resetToCheckpoint(); }
function win(){ alert(`Level complete! Rings: ${state.rings}`); resetToCheckpoint(); }

/* --- камера: БЕЗ смещений (сразу видно карту) --- */
let cam = {ox:0, oy:0};

/* --- цикл --- */
let last=performance.now();
console.log('DEBUG: running');
function loop(ts){
  const dt=Math.min(0.033,(ts-last)/1000); last=ts;

  // движение
  const SPEED=170, G=2000;
  state.vx = (keys.right - keys.left) * SPEED;
  state.vy += G*dt;

  const res = resolveAABB(state.px,state.py, 28,28, state.vx*dt, state.vy*dt);
  state.px=res.x; state.py=res.y; state.vx=res.vx/dt; state.vy=res.vy/dt; state.onGround=res.onGround;

  // события тайла
  const cx = Math.floor((state.px+14)/TILE), cy = Math.floor((state.py+14)/TILE);
  const t = tileAt(cx,cy);
  if(t==='2'){ hit(); }
  if(t==='3'){ state.rings++; rEl.textContent=state.rings; level[cy]=level[cy].slice(0,cx)+'_'+level[cy].slice(cx+1); }
  if(t==='4' && state.rings===state.total){ win(); }

  // РЕНДЕР
  ctx.clearRect(0,0,W,H);
  // тайлы рендерим от (0,0) — без камеры, чтобы точно увидеть
  for(let y=0;y<H_TILES;y++){
    for(let x=0;x<W_TILES;x++){
      const c = level[y][x];
      const sx = x*TILE - cam.ox, sy = y*TILE - cam.oy;
      if(c==='1'){ ctx.fillStyle='#6a4f3b'; ctx.fillRect(sx,sy,TILE,TILE); ctx.strokeStyle='#3c2b20'; ctx.strokeRect(sx+0.5,sy+0.5,TILE-1,TILE-1); }
      if(c==='2'){ ctx.fillStyle='#44c0ff'; ctx.beginPath(); ctx.moveTo(sx+16,sy+3); ctx.lineTo(sx+28,sy+29); ctx.lineTo(sx+4,sy+29); ctx.closePath(); ctx.fill(); }
      if(c==='3'){ ctx.strokeStyle='#ffd54a'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(sx+16, sy+16, 9, 0, Math.PI*2); ctx.stroke(); }
      if(c==='4'){ ctx.fillStyle='#70ff70'; ctx.fillRect(sx+8, sy+8, 16,16); }
    }
  }

  // игрок
  ctx.fillStyle='#ff2a2a';
  ctx.beginPath();
  ctx.arc(state.px - cam.ox + 14, state.py - cam.oy + 14, 14, 0, Math.PI*2);
  ctx.fill();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
