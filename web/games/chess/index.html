<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>Chess (Standalone)</title>
<style>
  :root{ --chx-bg:#0f0f12; --chx-text:#f3f6ff; --chx-muted:#9aa3b2; --chx-panel:#171a22; --chx-accent:#4e9eff; }
  body{margin:0;background:var(--chx-bg);color:var(--chx-text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .chx-wrap{max-width:980px;margin:0 auto;padding:12px;display:grid;gap:12px;grid-template-columns:1fr}
  @media(min-width:900px){ .chx-wrap{grid-template-columns:minmax(320px,1fr) 1fr;align-items:start} }
  .chx-header{padding:12px}
  .chx-title{margin:0;font-size:18px}
  .chx-sub{margin:2px 0 0;color:var(--chx-muted);font-size:12px}
  .chx-panel{background:var(--chx-panel);border-radius:14px;padding:12px;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .chx-panel select,.chx-panel button{border:0;border-radius:12px;padding:10px 12px;font-weight:600}
  .chx-btn{background:#2a2f3b;color:#fff;cursor:pointer}
  .chx-btn.primary{background:var(--chx-accent);color:#fff}
  .chx-info{background:var(--chx-panel);border-radius:14px;padding:12px}
  .chx-tags{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .chx-tag{background:#23283a;color:#fff;padding:6px 10px;border-radius:10px;font-size:12px}
  .chx-log{font:12px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#10131a;color:#e6ecff;border-radius:10px;padding:8px;max-height:220px;overflow:auto;white-space:pre-wrap}
  .chx-board-wrap{display:flex;justify-content:center}
  canvas#chx{display:block;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);background:#f0d9b5;max-width:100%;height:auto}
</style>
</head>
<body>
<header class="chx-header" id="chxHeader">
  <h1 class="chx-title">♟️ Chess</h1>
  <p class="chx-sub">Полностью автономные шахматы: Canvas + собственные фигуры. Без внешних библиотек.</p>
</header>

<main class="chx-wrap">
  <section class="chx-board-wrap">
    <canvas id="chx" width="480" height="480"></canvas>
  </section>

  <section>
    <div class="chx-panel" id="chxPanel">
      <label>Цвет:</label>
      <select id="chxColor"><option value="w">Белые</option><option value="b">Чёрные</option></select>
      <label>Режим:</label>
      <select id="chxMode"><option value="ai" selected>Против ИИ</option><option value="pvp">2 игрока</option></select>
      <label>Сложность:</label>
      <select id="chxLevel">
        <option value="newbie">Новичок</option>
        <option value="casual">Любитель</option>
        <option value="club">Клубный</option>
        <option value="master">Мастер</option>
        <option value="supergm" selected>Супер-гроссмейстер</option>
      </select>
      <button id="chxNew" class="chx-btn primary">Новая партия</button>
      <button id="chxFlip" class="chx-btn">Повернуть доску</button>
    </div>

    <div class="chx-info">
      <div class="chx-tags">
        <span class="chx-tag" id="chxTurn">Ход белых</span>
        <span class="chx-tag" id="chxStatus">Игра идёт</span>
        <span class="chx-tag" id="chxScore">—</span>
      </div>
      <h3 style="margin:12px 0 6px;font-size:14px">Журнал ходов (SAN)</h3>
      <div id="chxLog" class="chx-log"></div>
      <p class="chx-sub" style="margin-top:10px">Фигуры рисуются вектором на Canvas (наши формы) — лицензии не нарушаются.</p>
    </div>
  </section>
</main>

<script>
/* ========== адаптивная доска ========== */
const cvs=document.getElementById('chx'), ctx=cvs.getContext('2d');
const elHeader=document.getElementById('chxHeader'); const elPanel=document.getElementById('chxPanel');
let BOARD=480, S=60;
function resizeBoard(){
  const m=24, vw=innerWidth, vh=innerHeight;
  const headerH=elHeader?.getBoundingClientRect().height||0;
  const panelH=elPanel?.getBoundingClientRect().height||0;
  const availH=Math.max(240, vh-headerH-panelH-m*2), availW=vw-m*2;
  const side=Math.max(240, Math.floor(Math.min(availW, availH)));
  BOARD=side-(side%8); S=BOARD/8; cvs.width=BOARD; cvs.height=BOARD;
  if(st.flipped) ctx.setTransform(-1,0,0,-1, BOARD, BOARD); else ctx.setTransform(1,0,0,1, 0,0);
  render();
}
addEventListener('resize', ()=>{ clearTimeout(resizeBoard._t); resizeBoard._t=setTimeout(resizeBoard,120); }, {passive:true});

/* ========== состояние ========== */
const light='#f0d9b5', dark='#b58863'; const WHITE='w', BLACK='b';
function startBoard(){ return ['rnbqkbnr','pppppppp','........','........','........','........','PPPPPPPP','RNBQKBNR'].map(r=>r.split('')); }
const st={ board:startBoard(), turn:WHITE, wk:{r:7,c:4}, bk:{r:0,c:4}, castling:{K:true,Q:true,k:true,q:true}, ep:null, half:0, full:1, flipped:false, log:[],
           lastMove:null, // {fromR,fromC,r,c}
           anim:null       // {t0, dur, fromR,fromC,r,c, piece}
         };

/* ========== отрисовка доски/фигур ========== */
function drawBoard(){ for(let r=0;r<8;r++) for(let c=0;c<8;c++){ ctx.fillStyle=((r+c)&1)?dark:light; ctx.fillRect(c*S,r*S,S,S); } }

/* читабельные фигуры (король/ферзь/конь) */
function drawPiece(ch,r,c){
  const x=c*S+S/2, y=r*S+S/2; const white=ch===ch.toUpperCase();
  const fill=white?'#fff':'#111'; const stroke=white?'rgba(0,0,0,.35)':'rgba(255,255,255,.25)';
  ctx.save(); ctx.translate(x,y); ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=Math.max(2,S*0.035); ctx.lineJoin='round'; ctx.lineCap='round';
  const t=ch.toLowerCase();
  if(t==='p'){ const r1=S*0.18,w=S*0.26; ctx.beginPath();ctx.arc(0,-S*0.22,r1,0,6.283);ctx.fill();ctx.stroke(); ctx.beginPath();ctx.moveTo(-w,-S*0.08);ctx.quadraticCurveTo(0,-S*0.15,w,-S*0.08);ctx.lineTo(w,S*0.18);ctx.lineTo(-w,S*0.18);ctx.closePath();ctx.fill();ctx.stroke(); ctx.fillRect(-S*0.32,S*0.22,S*0.64,S*0.06); }
  else if(t==='r'){ const w=S*0.32,h=S*0.34; ctx.beginPath();ctx.rect(-w,-h,w*2,h*1.1);ctx.fill();ctx.stroke(); for(let i=-1;i<=1;i++) ctx.fillRect(i*S*0.12-S*0.05,-h-S*0.05,S*0.10,S*0.06); ctx.fillRect(-S*0.36,h*0.8,S*0.72,S*0.06); ctx.fillRect(-S*0.42,h*0.98,S*0.84,S*0.04); }
  else if(t==='n'){ // новый конь
    const s=S; ctx.beginPath();
    ctx.moveTo(-0.26*s,0.22*s); ctx.bezierCurveTo(-0.12*s,-0.02*s,0.00*s,-0.22*s,0.16*s,-0.28*s);
    ctx.lineTo(0.12*s,-0.46*s); ctx.lineTo(0.02*s,-0.30*s);
    ctx.bezierCurveTo(-0.10*s,-0.28*s,-0.02*s,-0.15*s,0.10*s,-0.14*s);
    ctx.bezierCurveTo(0.03*s,-0.06*s,-0.04*s,0.03*s,-0.16*s,0.06*s);
    ctx.bezierCurveTo(-0.24*s,0.10*s,-0.28*s,0.16*s,-0.26*s,0.22*s);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0.08*s,-0.28*s); ctx.lineTo(-0.06*s,-0.18*s); ctx.moveTo(0.05*s,-0.24*s); ctx.lineTo(-0.08*s,-0.12*s); ctx.stroke();
    ctx.beginPath(); ctx.arc(0.02*s,-0.20*s, s*0.02, 0, 6.283); ctx.fillStyle=white?'#222':'#eee'; ctx.fill();
    ctx.fillStyle=fill; ctx.fillRect(-s*0.30, s*0.24, s*0.60, s*0.06);
  }
  else if(t==='b'){ ctx.beginPath();ctx.moveTo(0,-S*0.30);ctx.bezierCurveTo(S*0.18,-S*0.12,S*0.18,S*0.04,0,S*0.18);ctx.bezierCurveTo(-S*0.18,S*0.04,-S*0.18,-S*0.12,0,-S*0.30);ctx.fill();ctx.stroke(); ctx.beginPath();ctx.moveTo(0,-S*0.24);ctx.lineTo(0,S*0.10);ctx.stroke(); ctx.fillRect(-S*0.26,S*0.18,S*0.52,S*0.06); }
  else if(t==='q'){ // ферзь без креста
    for(let i=-2;i<=2;i++){ ctx.beginPath();ctx.arc(i*S*0.08,-S*0.30,S*0.045,0,6.283);ctx.fill();ctx.stroke(); }
    ctx.beginPath();ctx.moveTo(-S*0.30,-S*0.18);ctx.quadraticCurveTo(0,-S*0.32,S*0.30,-S*0.18);ctx.lineTo(S*0.26,S*0.18);ctx.lineTo(-S*0.26,S*0.18);ctx.closePath();ctx.fill();ctx.stroke();
    ctx.fillRect(-S*0.30,S*0.18,S*0.60,S*0.06);
  }
  else if(t==='k'){ // король — крест ярко выражен
    ctx.fillRect(-S*0.05,-S*0.52,S*0.10,S*0.18); ctx.fillRect(-S*0.22,-S*0.44,S*0.44,S*0.10);
    ctx.beginPath();ctx.moveTo(-S*0.24,-S*0.20);ctx.quadraticCurveTo(0,-S*0.36,S*0.24,-S*0.20);ctx.lineTo(S*0.22,S*0.16);ctx.lineTo(-S*0.22,S*0.16);ctx.closePath();ctx.fill();ctx.stroke();
    ctx.fillRect(-S*0.32,S*0.18,S*0.64,S*0.06);
  }
  ctx.restore();
}

/* выделения */
let sel=null, movesCache=[], illegalKingSquares=[];
function drawHighlights(){
  // подсветка последнего хода
  if(st.lastMove){
    ctx.save(); ctx.globalAlpha=.35; ctx.fillStyle='#ffd54f';
    ctx.fillRect(st.lastMove.fromC*S, st.lastMove.fromR*S, S, S);
    ctx.fillRect(st.lastMove.c*S,     st.lastMove.r*S,     S, S);
    ctx.restore();
  }
  // допустимые ходы зелёным кружком / взятие красным квадратом
  if(sel){
    ctx.save();
    movesCache.forEach(m=>{
      if(m.capture){ ctx.globalAlpha=.35; ctx.fillStyle='rgba(220,50,50,.45)'; ctx.fillRect(m.c*S, m.r*S, S, S); }
      else { ctx.globalAlpha=.6; ctx.fillStyle='rgba(50,140,255,.35)'; const cx=m.c*S+S/2, cy=m.r*S+S/2; ctx.beginPath(); ctx.arc(cx,cy, S*0.14, 0, 6.283); ctx.fill(); }
    });
    // ЗАПРЕЩЁННЫЕ для короля поля — полупрозрачным красным
    if(illegalKingSquares.length){
      ctx.globalAlpha=.22; ctx.fillStyle='rgba(255,0,0,.55)';
      illegalKingSquares.forEach(q=> ctx.fillRect(q.c*S,q.r*S,S,S));
    }
    ctx.restore();
  }
}

/* анимация перемещения */
function animateMove(piece, fromR,fromC, toR,toC, done){
  const dur=180; const t0=performance.now();
  st.anim={t0,dur,fromR,fromC,r:toR,c:toC,piece};
  function step(now){
    const t=Math.min(1,(now-t0)/dur);
    render(true); // без повторной отрисовки фигур на from/to
    // интерполяция
    const x=(fromC+(toC-fromC)*t)*S+S/2;
    const y=(fromR+(toR-fromR)*t)*S+S/2;
    // рисуем «летящую» фигуру поверх
    drawPiece(piece, 0,0); // трюк: используем drawPiece с переносом:
  }
  // переписка drawPiece не позволяет рисовать по абсолютным px, поэтому ниже – локальная отрисовка:
  st.anim.draw=function(now){
    const t=Math.min(1,(now-t0)/dur);
    const x=(fromC+(toC-fromC)*t)*S+S/2;
    const y=(fromR+(toR-fromR)*t)*S+S/2;
    const white=st.anim.piece===st.anim.piece.toUpperCase();
    const fill=white?'#fff':'#111'; const stroke=white?'rgba(0,0,0,.35)':'rgba(255,255,255,.25)';
    const tcode=st.anim.piece.toLowerCase();
    // мини-отрисовка: временно смещаем канву и зовём штатную функцию
    ctx.save(); ctx.translate(x,y);
    // ниже — та же логика, что в drawPiece, но компактно:
    ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=Math.max(2,S*0.035); ctx.lineJoin='round'; ctx.lineCap='round';
    // ради экономии — просто вызываем оригинал с координатами клетки
    ctx.restore();
    // хитрость: временно рисуем в клетку, а канву смещаем:
    // делаем маленький «обман»: подменим translate, вызвав drawPiece на фейковой клетке
    const bak=ctx.getTransform(); ctx.setTransform(1,0,0,1,0,0);
    // перерисуем фигуру по центру (используем ту же функцию)
    (function tmp(){ const ch=st.anim.piece; const r=0,c=0; const x=x0=>{} })();
  };
  // упростим: анимация короткая — просто сделаем flash (без скольжения), чтобы не раздувать код
  setTimeout(()=>{ st.anim=null; done&&done(); render(); }, dur);
}

/* полный рендер с возможной анимацией */
function render(skipPieces){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  drawBoard();
  drawHighlights();
  drawPieces();
  // (упрощённая анимация — сейчас делаем быстрый flash подсветкой; скольжение оставил как задел)
}

/* ========== правила/ходы ========== */
const WHITEc='w', BLACKc='b';
function pieceColor(ch){ return (ch===ch.toUpperCase())?WHITEc:BLACKc; }
function inBoard(r,c){ return r>=0&&r<8&&c>=0&&c<8; }
function cloneBoard(b){ return b.map(r=>r.slice()); }
function kingSquare(color){ return color===WHITEc?st.wk:st.bk; }

function isAttacked(b,r,c,by){
  const dir=(by===WHITEc)?-1:1;
  for(const dc of [-1,1]){ const rr=r+dir,cc=c+dc; if(inBoard(rr,cc)){ const ch=b[rr][cc]; if(ch!=='.'&&pieceColor(ch)===by&&ch.toLowerCase()==='p') return true; } }
  const K=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
  for(const [dr,dc] of K){ const rr=r+dr,cc=c+dc; if(inBoard(rr,cc)){ const ch=b[rr][cc]; if(ch!=='.'&&pieceColor(ch)===by&&ch.toLowerCase()==='n') return true; } }
  const D=[[1,1],[1,-1],[-1,1],[-1,-1]];
  for(const [dr,dc] of D){ let rr=r+dr,cc=c+dc; while(inBoard(rr,cc)){ const ch=b[rr][cc]; if(ch!=='.'){ if(pieceColor(ch)===by&&(ch.toLowerCase()==='b'||ch.toLowerCase()==='q')) return true; break; } rr+=dr;cc+=dc; } }
  const R=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const [dr,dc] of R){ let rr=r+dr,cc=c+dc; while(inBoard(rr,cc)){ const ch=b[rr][cc]; if(ch!=='.'){ if(pieceColor(ch)===by&&(ch.toLowerCase()==='r'||ch.toLowerCase()==='q')) return true; break; } rr+=dr;cc+=dc; } }
  for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr||dc){ const rr=r+dr,cc=c+dc; if(inBoard(rr,cc)){ const ch=b[rr][cc]; if(ch!=='.'&&pieceColor(ch)===by&&ch.toLowerCase()==='k') return true; } } }
  return false;
}

/* короля «съесть» нельзя — такие ходы отсекаем */
function addIfNotKingCapture(list,m){
  const tgt=st.board[m.r]?.[m.c]; if(tgt && tgt!=='.' && tgt.toLowerCase()==='k') return; list.push(m);
}

function generateMoves(color){
  const res=[];
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const ch=st.board[r][c]; if(ch==='.'||pieceColor(ch)!==color) continue;
    const t=ch.toLowerCase();
    if(t==='p'){
      const dir=(color===WHITEc)?-1:1, start=(color===WHITEc)?6:1, promoRow=(color===WHITEc)?0:7;
      if(inBoard(r+dir,c)&&st.board[r+dir][c]==='.') addIfNotKingCapture(res,{r:r+dir,c,fromR:r,fromC:c});
      if(r===start && st.board[r+dir][c]==='.' && st.board[r+2*dir][c]==='.') addIfNotKingCapture(res,{r:r+2*dir,c,fromR:r,fromC:c,epGive:{r:r+dir,c}});
      for(const dc of [-1,1]){ const rr=r+dir,cc=c+dc; if(inBoard(rr,cc)){ const tg=st.board[rr][cc]; if(tg!=='.'&&pieceColor(tg)!==color) addIfNotKingCapture(res,{r:rr,c:cc,fromR:r,fromC:c,capture:true}); } }
      if(st.ep && st.ep.r===r+dir && Math.abs(st.ep.c-c)===1) addIfNotKingCapture(res,{r:st.ep.r,c:st.ep.c,fromR:r,fromC:c,capture:true,ep:true,epVictim:{r:r,c:st.ep.c}});
      for(const m of res.filter(m=>m.fromR===r&&m.fromC===c)){ if(m.r===promoRow) m.promo='q'; }
    } else if(t==='n'){
      const K=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
      for(const [dr,dc] of K){ const rr=r+dr,cc=c+dc; if(!inBoard(rr,cc)) continue; const tg=st.board[rr][cc]; if(tg==='.'||pieceColor(tg)!==color) addIfNotKingCapture(res,{r:rr,c:cc,fromR:r,fromC:c,capture:tg!=='.'}); }
    } else if(t==='b'||t==='r'||t==='q'){
      const dirs=t==='b'?[[1,1],[1,-1],[-1,1],[-1,-1]]:t==='r'?[[1,0],[-1,0],[0,1],[0,-1]]:[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dr,dc] of dirs){ let rr=r+dr,cc=c+dc; while(inBoard(rr,cc)){ const tg=st.board[rr][cc]; if(tg==='.') addIfNotKingCapture(res,{r:rr,c:cc,fromR:r,fromC:c}); else { if(pieceColor(tg)!==color) addIfNotKingCapture(res,{r:rr,c:cc,fromR:r,fromC:c,capture:true}); break; } rr+=dr;cc+=dc; } }
    } else if(t==='k'){
      for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr||dc){ const rr=r+dr,cc=c+dc; if(!inBoard(rr,cc)) continue; const tg=st.board[rr][cc]; if(tg==='.'||pieceColor(tg)!==color) addIfNotKingCapture(res,{r:rr,c:cc,fromR:r,fromC:c,capture:tg!=='.'}); } }
      if(color===WHITEc && r===7 && c===4){
        if(st.castling.K && st.board[7][5]==='.' && st.board[7][6]==='.' && !isAttacked(st.board,7,4,BLACKc) && !isAttacked(st.board,7,5,BLACKc) && !isAttacked(st.board,7,6,BLACKc)) res.push({r:7,c:6,fromR:7,fromC:4,castle:'K'});
        if(st.castling.Q && st.board[7][3]==='.' && st.board[7][2]==='.' && st.board[7][1]==='.' && !isAttacked(st.board,7,4,BLACKc) && !isAttacked(st.board,7,3,BLACKc) && !isAttacked(st.board,7,2,BLACKc)) res.push({r:7,c:2,fromR:7,fromC:4,castle:'Q'});
      }
      if(color===BLACKc && r===0 && c===4){
        if(st.castling.k && st.board[0][5]==='.' && st.board[0][6]==='.' && !isAttacked(st.board,0,4,WHITEc) && !isAttacked(st.board,0,5,WHITEc) && !isAttacked(st.board,0,6,WHITEc)) res.push({r:0,c:6,fromR:0,fromC:4,castle:'k'});
        if(st.castling.q && st.board[0][3]==='.' && st.board[0][2]==='.' && st.board[0][1]==='.' && !isAttacked(st.board,0,4,WHITEc) && !isAttacked(st.board,0,3,WHITEc) && !isAttacked(st.board,0,2,WHITEc)) res.push({r:0,c:2,fromR:0,fromC:4,castle:'q'});
      }
    }
  }
  // фильтр: свой король не должен оказаться под шахом
  const legal=[];
  for(const m of res){
    const b=cloneBoard(st.board); const pc=b[m.fromR][m.fromC];
    b[m.fromR][m.fromC]='.'; if(m.ep) b[m.epVictim.r][m.epVictim.c]='.'; b[m.r][m.c]= m.promo ? (pieceColor(pc)===WHITEc?'Q':'q') : pc;
    if(m.castle){ if(m.castle==='K'){b[7][7]='.';b[7][5]='R';} if(m.castle==='Q'){b[7][0]='.';b[7][3]='R';} if(m.castle==='k'){b[0][7]='.';b[0][5]='r';} if(m.castle==='q'){b[0][0]='.';b[0][3]='r';} }
    const kpos=(pc.toLowerCase()==='k')?{r:m.r,c:m.c}:kingSquare(color);
    if(!isAttacked(b,kpos.r,kpos.c,color===WHITEc?BLACKc:WHITEc)) legal.push(m);
  }
  return legal;
}

/* вычисляем «запрещённые» для короля клетки (псевдолегальные минус легальные) */
function kingIllegalSquares(r,c){
  const color=pieceColor(st.board[r][c]); const illegal=[];
  const pseudo=[];
  for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr||dc){ const rr=r+dr,cc=c+dc; if(!inBoard(rr,cc)) continue; const tg=st.board[rr][cc]; if(tg==='.'||pieceColor(tg)!==color) pseudo.push({r:rr,c:cc,fromR:r,fromC:c}); } }
  const legal=generateMoves(color).filter(m=>m.fromR===r&&m.fromC===c).map(m=>m.r+','+m.c);
  for(const q of pseudo){ if(!legal.includes(q.r+','+q.c)) illegal.push(q); }
  return illegal;
}

function makeMove(m){
  const pc=st.board[m.fromR][m.fromC];
  st.board[m.fromR][m.fromC]='.'; if(m.ep) st.board[m.epVictim.r][m.epVictim.c]='.'; st.board[m.r][m.c]= m.promo ? (pieceColor(pc)===WHITEc?'Q':'q') : pc;
  if(pc==='K') st.wk={r:m.r,c:m.c}; if(pc==='k') st.bk={r:m.r,c:m.c};
  if(m.castle){ if(m.castle==='K'){st.board[7][7]='.';st.board[7][5]='R';} if(m.castle==='Q'){st.board[7][0]='.';st.board[7][3]='R';} if(m.castle==='k'){st.board[0][7]='.';st.board[0][5]='r';} if(m.castle==='q'){st.board[0][0]='.';st.board[0][3]='r';} }
  if(pc==='K'){st.castling.K=false;st.castling.Q=false;} if(pc==='k'){st.castling.k=false;st.castling.q=false;}
  if(pc==='R'&&m.fromR===7&&m.fromC===7) st.castling.K=false; if(pc==='R'&&m.fromR===7&&m.fromC===0) st.castling.Q=false;
  if(pc==='r'&&m.fromR===0&&m.fromC===7) st.castling.k=false; if(pc==='r'&&m.fromR===0&&m.fromC===0) st.castling.q=false;
  st.ep = m.epGive || null; st.turn=(st.turn===WHITEc)?BLACKc:WHITEc; st.full += (st.turn===WHITEc?1:0);
  st.lastMove={fromR:m.fromR,fromC:m.fromC,r:m.r,c:m.c};
}

/* ========== ИИ (ускорен и «матовее») ========== */
const LEVEL={newbie:{depth:1,noise:60,think:120},casual:{depth:2,noise:35,think:160},club:{depth:3,noise:15,think:240},master:{depth:4,noise:6,think:320},supergm:{depth:5,noise:0,think:420}};
const pieceVal={p:100,n:320,b:330,r:500,q:900,k:0};
const hist=[]; // для штрафа повторений
function edgeDist(r,c){ return Math.min(r,c,7-r,7-c); }
function mobility(ch,color){ return generateMoves(color).length * (color===WHITE?1:-1); }
function evaluate(){
  let s=0, whiteMat=0, blackMat=0;
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const ch=st.board[r][c]; if(ch==='.'){continue;}
    const v=pieceVal[ch.toLowerCase()]||0; s+=(ch===ch.toUpperCase()?1:-1)*v;
    if(ch===ch.toUpperCase()) whiteMat+=v; else blackMat+=v;
  }
  const endgame = (whiteMat<=1300 || blackMat<=1300); // примерно «мало фигур»
  // подгоняем короля соперника к краю (в эндшпиле это помогает доводить до мата)
  const ek = st.turn===WHITE ? st.bk : st.wk; // «враг»
  if(endgame){ s += (3 - edgeDist(ek.r,ek.c)) * 40 * (st.turn===WHITE?1:-1); }
  // небольшой бонус за мобильность текущей стороны и штраф сопернику
  s += mobility(st,WHITE) * 1.5;
  // штраф за повторение позиции (петляние)
  const key=st.board.map(r=>r.join('')).join('|')+st.turn;
  const repeats=hist.filter(k=>k===key).length; s -= repeats*30;
  return s;
}
function orderFor(color){ const ms=generateMoves(color); ms.sort((a,b)=>(b.capture?1:0)-(a.capture?1:0)); return ms; }
function search(depth,alpha,beta,color){
  if(depth===0) return evaluate()*(color===WHITE?1:-1);
  const ms=orderFor(color);
  if(!ms.length){ const k=kingSquare(color); const check=isAttacked(st.board,k.r,k.c,color===WHITE?BLACK:WHITE); return (check?-99999:0)*(color===WHITE?1:-1); }
  let best=-1e9; const snap=JSON.parse(JSON.stringify(st));
  for(const m of ms){
    makeMove(m);
    const sc=-search(depth-1,-beta,-alpha,color===WHITE?BLACK:WHITE);
    Object.assign(st,snap); st.board=snap.board.map(r=>r.slice());
    if(sc>best) best=sc; if(best>alpha) alpha=best; if(alpha>=beta) break;
  }
  return best;
}
function bestMove(level){
  const cfg=LEVEL[level]||LEVEL.casual, color=st.turn, ms=orderFor(color);
  if(!ms.length) return null;
  const snap=JSON.parse(JSON.stringify(st)); let scored=[];
  for(const m of ms){
    makeMove(m); const sc=-search(cfg.depth-1,-1e9,1e9,color===WHITE?BLACK:WHITE);
    Object.assign(st,snap); st.board=snap.board.map(r=>r.slice()); scored.push({m,sc});
  }
  if(cfg.noise) scored.forEach(s=> s.sc+=(Math.random()*2-1)*cfg.noise);
  scored.sort((a,b)=> b.sc-a.sc);
  return scored[0].m;
}

/* ========== UI/логика хода ========== */
const ui={ color:chxColor, level:chxLevel, mode:chxMode, btnNew:chxNew, btnFlip:chxFlip, turn:chxTurn, status:chxStatus, log:chxLog };
function uTurn(){ ui.turn.textContent = st.turn===WHITE?'Ход белых':'Ход чёрных'; }
function uStatus(t){ ui.status.textContent=t; }
function uLog(san){ if(!san) ui.log.textContent=''; else ui.log.textContent+=san+(st.turn===WHITE?'\n':' '); }
function sanOf(m,cap){ const p=st.board[m.fromR][m.fromC]; const name={p:'',n:'N',b:'B',r:'R',q:'Q',k:'K'}[p.toLowerCase()]; const file=String.fromCharCode(97+m.fromC), to=String.fromCharCode(97+m.c)+(8-m.r); return (name||(cap?file:''))+(cap?'x':'')+to+(m.promo?'=Q':''); }

function gameOver(){
  const ms=generateMoves(st.turn);
  if(!ms.length){
    const k=kingSquare(st.turn); const check=isAttacked(st.board,k.r,k.c, st.turn===WHITE?BLACK:WHITE);
    uStatus(check?'Мат':'Пат'); return true;
  }
  return false;
}
function checkGame(){ if(!gameOver()) uStatus('Игра идёт'); uTurn(); }

function clickBoard(ev){
  const rect=cvs.getBoundingClientRect(); let x=ev.clientX-rect.left, y=ev.clientY-rect.top;
  if(st.flipped){ x=rect.width-x; y=rect.height-y; }
  let c=Math.floor(x/S), r=Math.floor(y/S);
  if(!sel){
    const ch=st.board[r][c];
    if(ch!=='.' && pieceColor(ch)===st.turn){
      sel={r,c};
      movesCache=generateMoves(st.turn).filter(m=>m.fromR===r && m.fromC===c);
      illegalKingSquares = (ch.toLowerCase()==='k') ? kingIllegalSquares(r,c) : [];
    }
  }else{
    const mv=movesCache.find(m=>m.r===r && m.c===c);
    if(mv){
      const cap=!!mv.capture || mv.ep; const san=sanOf(mv,cap);
      // мгновенно выполняем ход (до 1 сек): без задержки, с подсветкой последнего хода
      hist.push(st.board.map(r=>r.join('')).join('|')+st.turn);
      makeMove(mv); uLog(san); checkGame(); render();
      // ответ ИИ
      if(ui.mode.value==='ai' && !gameOver() && ((st.turn===WHITE && ui.color.value==='b') || (st.turn===BLACK && ui.color.value==='w'))){
        uStatus('ИИ думает…');
        const choice=bestMove(ui.level.value);
        setTimeout(()=>{ if(choice){ const san2=sanOf(choice, !!choice.capture||choice.ep); hist.push(st.board.map(r=>r.join('')).join('|')+st.turn); makeMove(choice); uLog(san2); } checkGame(); render(); }, (LEVEL[ui.level.value]||{}).think||240);
      }
    }
    sel=null; movesCache=[]; illegalKingSquares=[];
  }
  render();
}

function resetGame(){
  st.board=startBoard(); st.turn=WHITE; st.wk={r:7,c:4}; st.bk={r:0,c:4};
  st.castling={K:true,Q:true,k:true,q:true}; st.ep=null; st.half=0; st.full=1;
  sel=null; movesCache=[]; illegalKingSquares=[]; st.lastMove=null; ui.log.textContent=''; hist.length=0;
  if(ui.color.value==='b'){ const mv=bestMove(ui.level.value); if(mv) makeMove(mv); }
  render(); checkGame();
}
function flipBoard(){ st.flipped=!st.flipped; ctx.setTransform(st.flipped?-1:1,0,0,st.flipped?-1:1, st.flipped?BOARD:0, st.flipped?BOARD:0); render(); }

/* init */
cvs.addEventListener('click', clickBoard);
ui.btnNew.addEventListener('click', resetGame);
ui.btnFlip.addEventListener('click', flipBoard);
resizeBoard(); render(); resetGame();
</script>
</body>
</html>
